| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 91389 | 37775 | 28180 | 39.293% |

## 문제

수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.

## 출력

총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.

## 제한

- 1 ≤ N ≤ 100,000
- 1 ≤ M ≤ 100,000
- 1 ≤ i ≤ j ≤ N

## 예제 입력 1

```
5 3 	   # 데이터의 개수, 구해야 할 합의 개수
5 4 3 2 1  # 구간 합을 구할 대상 배열
1 3 	   # 합을 구해야 할 구간 i, j
2 4
5 5
```

## 예제 출력 1

```
12
9
1
```

---

## 문제 분석하기

- 구간마다 합을 매번 계산하면 주어진 시간(0.5초) 안에 모든 구간 합 계산을 끝낼 수 없음
- **구간 합** 개념을 이용해, **합 배열을 미리** 만들어 놓고 조건에 맞는 구간 합을 출력!

<br>

**인덱스**    |   1   2   3   4   5

**리스트 A**  |  5   4   3   2   1

**합 배열 S**  |  5   9  12  14  15

<br>

여기서 

S[1] = S[0] + A[1] = 0 + 5 = 5

S[2] = S[1] + A[2] = 5 + 4 = 9

```python
# 합 배열 공식
S[i] = S[i-1] + A[i]
# A는 입력받은 리스트, S는 합 배열
# i번째까지의 합 = i-1번째까지의 합 + i번째 요소
```

<br>

**리스트 A의 A[2]부터 A[5]까지의 구간 합**은

A[0] + … + A[5]에서 A[0] + A[1]을 빼면 구간 합 A[2] + … A[5]가 나오므로, 

**S[5]에서 S[1]을 빼면** 구간 합을 구할 수 있음

(여기서 5는 j, 2은 i에 해당)

```python
# 구간 합 공식
S[j] - S[i-1]
# Ex) 2(i), 5(j): S[5] - S[1] = 15 - 5 = 10
```

## 소스 코드

```python
import sys
input = sys.stdin.readline
# input을 sys.stdin.readline으로 대체, 한 줄씩 입력받아 입력 속도를 빠르게  

n, m = map(int, input().split())
numlist = list(map(int, input().split()))

sumlist = [0] # 합 배열 변수
temp = 0

# 합 배열 만들기
# 저장한 숫자 데이터 차례대로 탐색
for i in numlist: 
	# temp에 현재 숫자 데이터 더해 주기
  temp = temp + i 
	# 합 배열에 temp값 저장
  sumlist.append(temp)

# 구간 합 구해 출력하기
# 합 구해야 하는 횟수 만큼 반복
for i in range(m):
	# 구간 합 범위 입력받기
  s, e = map(int, input().split())
	# 합 배열에서 구간 합 구하기
  print(sumlist[e] - sumlist[s-1])
```
